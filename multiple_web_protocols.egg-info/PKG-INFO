Metadata-Version: 2.4
Name: multiple-web-protocols
Version: 0.1.0
Summary: Add your description here
Requires-Python: >=3.11
Description-Content-Type: text/markdown
Requires-Dist: aiokafka>=0.13.0
Requires-Dist: email-validator>=2.3.0
Requires-Dist: fastapi>=0.104.1
Requires-Dist: grpcio>=1.76.0
Requires-Dist: grpcio-tools>=1.76.0
Requires-Dist: gunicorn>=24.1.1
Requires-Dist: lxml>=6.0.2
Requires-Dist: motor>=3.7.1
Requires-Dist: pydantic>=2.12.5
Requires-Dist: pymongo>=4.16.0
Requires-Dist: python-dotenv>=1.2.1
Requires-Dist: pytz>=2025.2
Requires-Dist: spyne>=2.14.0
Requires-Dist: strawberry-graphql[fastapi]>=0.289.8
Requires-Dist: tenacity>=9.1.2
Requires-Dist: types-protobuf>=6.32.1.20251210
Requires-Dist: uvicorn[standard]>=0.24.0

# Multiple Web Protocols

[![CI (lint + test)](https://github.com/blitznihar/multiple-web-protocols/actions/workflows/pylint.yml/badge.svg)](https://github.com/blitznihar/multiple-web-protocols/actions/workflows/pylint.yml)
[![codecov](https://codecov.io/github/blitznihar/multiple-web-protocols/graph/badge.svg?token=WQj9qZBFhi)](https://codecov.io/github/blitznihar/multiple-web-protocols)
![Python](https://img.shields.io/badge/python-3.11%2B-blue)
![Last Commit](https://img.shields.io/github/last-commit/blitznihar/multiple-web-protocols)
![License](https://img.shields.io/github/license/blitznihar/multiple-web-protocols?cacheSeconds=0)
![License](https://img.shields.io/badge/license-MIT-green)

## Overview

This repository is a learning/demo project that implements a simple **Customer** service backed by **MongoDB**, exposed over multiple web protocols.

The goal is to show how the same domain and persistence layer (a small customer database) can be accessed through different integration styles:

- A fully implemented **gRPC** service
- A fully implemented **REST** API (FastAPI)
- A fully implemented **SOAP** service (using Spyne)
- Planned/placeholder entry points for **WebSocket**, **Webhook**, **GraphQL**, **MCP** (Model Context Protocol), **AMQP**, **MQTT**, and **SSE**

All variants share the same MongoDB-backed `CustomerDB` abstraction for CRUD operations.

## Architecture

- **Domain model**
	- `db/customer.py` defines a `Customer` Pydantic model (with an optional `Address`).
	- `db/address.py` holds the address model used by `Customer`.

- **Persistence layer**
	- `db/customer_db.py` wraps a `pymongo.MongoClient` and exposes:
		- `create_customer(customer: dict) -> str`
		- `get_customer_by_id(customerid: str) -> dict | None`
		- `list_customers() -> list[dict]`
		- `update_customer(customerid: str, updates: dict) -> bool`
		- `delete_customer(customerid: str) -> bool`

- **Protocols**
	- **gRPC** (implemented)
		- Service definition in `grpc_service/proto/customer.proto`.
		- Generated code in `grpc_service/customerpb/`.
		- Server implementation in `grpc_service/server.py` wrapping `CustomerDB`.
		- Exposes CRUD RPCs: `CreateCustomer`, `GetCustomerById`, `UpdateCustomer`, `DeleteCustomer`.
	- **REST API** (implemented)
		- FastAPI application in `rest/app.py` exposing JSON endpoints over HTTP.
		- Uses the same `CustomerDB` to back CRUD operations.
		- Endpoints:
			- `GET /health` – basic app + MongoDB health-check.
			- `GET /customers` – list all customers.
			- `GET /customers/{customerid}` – fetch a single customer.
			- `POST /customers` – create a new customer (409 on duplicate `customerid`).
			- `PUT /customers/{customerid}` – update basic fields and nested address.
			- `DELETE /customers/{customerid}` – delete a customer.
	- **SOAP** (implemented)
		- Spyne-based SOAP service in `soap/customer_service.py` exposing WSDL and SOAP operations.
		- Uses the same `CustomerDB` for CRUD operations.
		- Operations:
			- `create_customer` – create a new customer.
			- `get_customer` – fetch a customer by ID.
			- `update_customer_email` – update a customer's email.
			- `delete_customer` – delete a customer by ID.
	- **WebSocket** (placeholder)
		- `websocket/__main__.py` currently prints a greeting and is a scaffold for a future WebSocket implementation.
	- **Webhook** (placeholder)
		- `webhook/__main__.py` currently prints a greeting and is a scaffold for incoming HTTP/webhook style integrations.
	- **GraphQL** (placeholder)
		- `graphql/__main__.py` currently prints a greeting and will eventually host a GraphQL API for the same `Customer` domain.
	- **MCP** (placeholder)
		- `mcp/__main__.py` is a placeholder for exposing the customer service via the Model Context Protocol.
	- **AMQP** (placeholder)
		- `amqp/__main__.py` is a placeholder for AMQP-based messaging.
	- **MQTT** (placeholder)
		- `mqtt/__main__.py` is a placeholder for MQTT-based messaging.
	- **SSE** (placeholder)
		- `sse/__main__.py` is a placeholder for Server-Sent Events.

- **Top-level demo**
	- `__main__.py` demonstrates the raw usage of `CustomerDB` (create, read, list, update, delete) when you run the project directly.

- **Infrastructure**
	- `docker-compose.yml` starts a local **MongoDB 7** instance with:
		- Database: `customerdb`
		- Initial data loaded from `data/customer.json` via `data/script/mongo-init.js`.

## Requirements

- Python ≥ 3.11 (project targets modern Python and uses type hints and Pydantic v2).
- A running MongoDB instance (or the included Docker Compose setup).

Recommended tooling (already configured in the project):

- [uv](https://github.com/astral-sh/uv) for dependency and environment management.
- `ruff`, `pylint`, and `pytest` for linting and testing.

## Getting Started

### 1. Start MongoDB with Docker

From the project root:

```bash
docker compose up -d
```

This will:

- Start `mongodb` on `localhost:27017`.
- Create the `customerdb` database.
- Seed it with sample data from `data/customer.json`.

### 2. Create / Activate the Virtual Environment (optional if you already use uv)

Using `uv` (recommended):

```bash
uv sync
```

This installs the dependencies declared in `pyproject.toml` and prepares a virtual environment.

To run commands inside that environment:

```bash
uv run <command>
```

Example:

```bash
uv run .
```

will run the package's `__main__.py` and execute the simple `CustomerDB` CRUD demo.

## Running the REST API

From the project root:

```bash
uv run rest
```

This starts a FastAPI/Uvicorn server, by default on `http://0.0.0.0:8060`, via `rest.__main__.py`.

Example requests (using `curl`):

```bash
curl http://localhost:8060/health
curl http://localhost:8060/customers
curl -X POST http://localhost:8060/customers \
	-H "Content-Type: application/json" \
	-d '{
				"customerid": "C1",
				"firstname": "Alice",
				"lastname": "Smith",
				"email": "alice@example.com",
				"phone": "+1-555-0000"
			}'
```

## Running the gRPC Service

### 1. Generate gRPC Stubs (if needed)

The generated files already live in `grpc_service/customerpb/`. If you change `grpc_service/proto/customer.proto`, you can regenerate them with:

```bash
cd grpc_service
./generate.sh
cd -
```

### 2. Start the gRPC Server

From the project root:

```bash
uv run python -m grpc_service.server
```

The server will listen on `localhost:50051` and log:

```text
✅ gRPC server running on :50051
```

### 3. Call the gRPC API

You can either:

- Use `grpcurl` from the command line, or
- Use the example client in `grpc_service/client.py` once implemented.

At a high level, the service supports:

- `CreateCustomer` – create a new customer with optional address.
- `GetCustomerById` – fetch a customer document by `customerid`.
- `UpdateCustomer` – partial updates on basic fields and nested address fields.
- `DeleteCustomer` – delete a customer by `customerid`.

## Running the SOAP Service

From the project root:

```bash
uv run soap
```

This starts a Spyne SOAP server, by default on `http://0.0.0.0:8067`, via `soap.__main__.py`.

The WSDL is available at: `http://localhost:8067/?wsdl`

Example operations (using a SOAP client or tools like SoapUI):

- `create_customer` – create a new customer.
- `get_customer` – fetch a customer by ID.
- `update_customer_email` – update a customer's email.
- `delete_customer` – delete a customer by ID.

## Running Other Protocol Entry Points

These modules are currently simple placeholders that just print a greeting, but the project wiring is already in place via `pyproject.toml` script entries:

```bash
uv run grpc       # mapped to grpc_service:main (implemented)
uv run rest       # mapped to rest:main (implemented)
uv run soap       # mapped to soap:main (implemented)
uv run websocket  # mapped to websocket:main (placeholder)
uv run webhook    # mapped to webhook:main (placeholder)
uv run graphql    # mapped to graphql:main (placeholder)
uv run mcp        # mapped to mcp:main (placeholder)
uv run amqp       # mapped to amqp:main (placeholder)
uv run mqtt       # mapped to mqtt:main (placeholder)
uv run sse        # mapped to sse:main (placeholder)
```

You can use these as starting points to flesh out full implementations for each protocol while reusing the shared `CustomerDB` persistence layer.

## Development

Install development dependencies:

```bash
uv sync --group dev
```

Run linters and tests:

```bash
uv run ruff check .
uv run pylint multiple-web-protocols  # or the relevant package path
uv run pytest
```

### Test Coverage

The test suite currently includes:

- gRPC service and helper tests in `tests/test_grpc_server.py` (service logic and status codes).
- MongoDB persistence tests in `tests/test_customer_db.py` using an in-memory fake `MongoClient`.
- REST API tests in `tests/test_rest_app.py` using FastAPI's `TestClient` and a fake `CustomerDB`.
- SOAP service tests in `tests/test_customer_service.py` using mocked `CustomerDB`.
- Environment configuration tests in `tests/test_envconfig.py` for `config/envconfig.py` properties.

All tests can be run together with:

```bash
uv run pytest
```

The repository is configured with a GitHub Actions workflow for linting and testing, and Codecov for coverage reporting.

## License

This project is licensed under the MIT License. See the `LICENSE` file for details.
